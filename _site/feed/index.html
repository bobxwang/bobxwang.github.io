<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>bob</title>
    <link href="http://sevenz.github.io/feed/" rel="self" />
    <link href="http://webfrogs.github.com" />
    <lastBuildDate>2016-01-26T15:35:37+08:00</lastBuildDate>
    <webMaster>ccf.developer@gmail.com</webMaster>
    
    <item>
      <title>Spring Cloud--基础概念</title>
      <link href="http://sevenz.github.io/code/basic-knlowledge-in-spring-cloud/"/>
      <pubDate>2015-06-05T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/basic-knlowledge-in-spring-cloud</guid>
      <content:encoded><![CDATA[<p>当今微服务在博客，社交媒体或会议演讲中获得越来越多关注，同时社区中也有不少怀疑论者，认为其并不是很新东西，而是对SOA架构的重新包装。然而微服务架构模式却正在为敏捷部署及复杂企业应用提供巨大的帮助。如想获得微服务的最新消息，可以关注其<a href="http://microservices.io/">官网</a>。</p>

<p>跨入微服务领域意味着我们正式迎接分布式系统所带来的诸多挑战，而分布式系统绝不是那种能够"凑合使用"的方案。</p>

<p>jvm平台的著名开源库Spring将<a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/">spring-boot</a>与<a href="http://netflix.github.io/">netflix</a>的库相结合，推出了<a href="http://projects.spring.io/spring-cloud/spring-cloud.html">spring-cloud</a>。</p>

<p>spring-cloud为开发者提供了在分布式系统(如配置服务，服务发现，断路器，智能路由，控制总线，一次性Token，全局锁)等操作的开发工具，目前已经提供在<a href="http://mvnrepository.com/search?q=spring+cloud">Maven</a>中央仓库中。</p>

<p>spring cloud包含一大堆子项目，已经开源在github上面，可以在<a href="https://github.com/spring-cloud/">这里</a>查看。</p>

<blockquote><p><strong>spring cloud cli</strong></p>

<p><strong>spring cloud context</strong></p>

<p><strong>spring cloud commons</strong></p>

<p><strong>spring cloud config</strong></p>

<p><strong>spring cloud netflix</strong>：service discovery: Eureka; circuit breaker: Hystrix; client side loadbalancer: Ribbon; declarative rest client: Feign; router and filter: Zuul(Reverse Proxy)</p></blockquote>

<p>当然，服务注册发现这块，spring cloud除了netflix公司的Eureka之外，也可以选择consul或者zookeeper。</p>

<p>下文将会对每个子项目做个说明。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Spark随谈--基础概念</title>
      <link href="http://sevenz.github.io/code/the-basic-concept-of-spark/"/>
      <pubDate>2014-01-05T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/the-basic-concept-of-spark</guid>
      <content:encoded><![CDATA[<blockquote><p><strong>Application</strong>:基于Spark的用户程序，包含了一个driver program和集群中多个executor</p>

<p><strong>Driver Program</strong>:运行Application的main()函数并创建SparkContext。通常SparkContext代表driver program</p>

<p><strong>Executor</strong>:为某Application运行在worker node上的一个进程。该进程负责运行Task，并负责将数据存在内存或者磁盘上。每个Application都有自己独立的executors</p>

<p><strong>Cluster Manager</strong>:在集群上获得资源的外部服务（例如 Spark Standalon，Mesos、Yarn)
<strong>Worker Node</strong>:集群中任何可运行Application代码的节点</p>

<p><strong>Task</strong>:被送到executor上执行的工作单元。</p>

<p><strong>Job</strong>:可以被拆分成Task并行计算的工作单元，一般由Spark Action触发的一次执行作业。</p>

<p><strong>Stage</strong>:每个Job会被拆分成很多组Task，每组任务被称为stage，也可称TaskSet。该术语可以经常在日志中看打。</p>

<p><strong>RDD</strong>:Spark的基本计算单元，通过Scala集合转化、读取数据集生成或者由其他RDD经过算子操作得到。</p></blockquote>

<h2>SparkConf</h2>

<p>对于spark的环境做一些基本设置</p>

<pre>conf = SparkConf().setAppName('APP_NAME')
conf.setMaster('local')
</pre>


<h2>SparkContext</h2>

<p>通过前面设置好的conf,构造出一个spark的上下文环境，作为一个操作和调度的总入口</p>

<pre>sc = SparkContext(conf=conf)
</pre>


<h2>RDD</h2>

<p><strong>Resilient Distributed Datasets</strong>，是一个容错的，并行的数据结构，可以让用户显示地将数据存储到磁盘和内存中，并能控制数据的分区，本质上，RDD是一个数据集。RDD将操作分成两类，<em>transformation</em>跟<em>action</em>，无论你执行了多少次transformation操作，RDD都不会真正执行运算，只有当action操作被执行时，运算才会触发，在其内部实现机制中是基于迭代器的，从而使数据的访问更高效。</p>

<p><strong>Transformation</strong>，根据现有的数据集创建一个新的数据集</p>

<ul>
<li><p>map(func):对调用map的RDD数据集中的每个element都使用func，然后返回一个新的RDD</p></li>
<li><p>filter(func):对调用filter的RDD数据集中的每个元素都使用func，然后返回一个包含使func为true的元素构成的RDD</p></li>
<li><p>flatMap(func):和map差不多，但是flatMap对于每个输入元素生成的是0或多个结果，因此func函数返回值不是一个单一元素，而是一个序列</p></li>
<li><p>groupByKey(numTasks):返回(K,Seq[V])，也就是hadoop中reduce函数接受的key-valuelist</p></li>
<li><p>reduceByKey(func,[numTasks]):就是用一个给定的reduce func再作用在groupByKey产生的(K,Seq[V]),比如求和，求平均数</p></li>
<li><p>sortByKey([ascending],[numTasks]):按照key来进行排序，是升序还是降序，ascending是boolean类型</p></li>
</ul>


<blockquote><p><strong>narrow dependencies</strong>
子RDD的每个分区依赖于常数个父分区（与数据规模无关）
输入输出一对一的算子，且结果RDD的分区结构不变。主要是map/flatmap
输入输出一对一的算子，但结果RDD的分区结构发生了变化，如union/coalesce
从输入中选择部分元素的算子，如filter、distinct、substract、sample</p>

<p><strong>wide dependencies</strong>
子RDD的每个分区依赖于所有的父RDD分区
对单个RDD基于key进行重组和reduce，如groupByKey，reduceByKey
对两个RDD基于key进行join和重组，如join
经过大量shuffle生成的RDD，建议进行缓存。这样避免失败后重新计算带来的开销。</p></blockquote>

<p><strong>Action</strong>，在数据集上运行计算后，返回一个值给驱动程序</p>

<ul>
<li><p>reduce(func):说白了就是聚集，接受传入的函数是两个参数输入返回一个值，这个函数必须是满足交换律和结合律的</p></li>
<li><p>saveAsTextFile(path):把dataset写到一个text file中，或者hdfs，或者hdfs支持的文件系统中，spark把每条记录都转换为一行记录，然后写到file中</p></li>
<li><p>saveAsSequenceFile(path):只能用在key-value对上，然后生成SequenceFile写到本地或者hadoop文件系统</p></li>
</ul>


<pre>data = [1,2,3,4,5]
distData = sc.parallelize(data)
lines = sc.textFile('data.txt')
linelengths = lines.map(lambda s: len(s))
totallength = linelengths.reduce(lambda a,b: a+b)
</pre>


<h2>Shared Variables</h2>

<p>一般来说，当一个函数被传给Spark操作(map/reduce)，通常是在集群结点上运行，在函数中使用到的所有变量都分别做拷贝供函数操作而不会相互影响，而在这些函数中对变量所做的所有更新都不会被传播回驱动程序。然而Spark提供两种有限的共享变量：广播跟累加。</p>

<h5>Broadcast Vaiables: 广播变量，可以在每台机器上缓存只读变量而不需要为各个任务发送该变量的拷贝，可以让大的输入数据集的集群拷贝中的节点更加高效</h5>

<pre>broadcastVar = sc.broadcase([1,2,3])
</pre>


<h5>Accumulators: 累加器，只有驱动程序才能获取累加器的值</h5>

<pre>accum = sc.accumulator(0)
sc.parallelize([1,2,3,4]).foreach(lambda x:accum.add(x))
</pre>

]]></content:encoded>
    </item>
    
    <item>
      <title>Asp.Net WebApi跟Spring Rest的Controller对比</title>
      <link href="http://sevenz.github.io/code/compare-the-aspwebapi-with-spring-rest/"/>
      <pubDate>2013-10-09T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/compare-the-aspwebapi-with-spring-rest</guid>
      <content:encoded><![CDATA[<p>自从11年底接触Asp.net Web Api开始到现在转眼也快三年了，做个日志对比下开源框架Spring Rest。</p>

<h3>Asp.net Web Api Controller Select &amp;&amp; Spring Rest Controller Select</h3>

<p>众所周知，HttpModule跟HttpHandler在Net Framework中是很重要的两个概念，在Web Api中一样，IIS接收到请求后，会查找一个叫做IRouteHandler的实现类，默认是HttpControllerRouterHander，中间会途径一系列的MessageHandler，HttpControllerDispatcher，DefaultHttpControllerActivator，最终会根据我们事先配置好的路由来选择一个Controller接收这个请求。</p>

<p>基于Spring的web应用最开始我们需要配一个DispatcherServlet的servlet-name，这个servlet会负责接收过来的所有请求，然后根据相应的配置<pre>HandlerMapping
--BeanNameUrlHandlerMapping
--SimpleUrlHandlerMapping
--ControllerClassNameHandlerMapping
--DefaultAnnotationHandlerMapping)</pre>选择一个具体的Controller来接收这个请求。</p>

<h3>Parameter Bind</h3>

<p>不管什么平台，客户端过来的数据服务端都会处理成一个NameValueCollection这样一个角色，然后我们自己根据相应的name在这个角色中获得value。不过如果需要我们自己去取，那这样也就谈不上框架了，太Low了点。</p>

<h5>Get</h5>

<p>Asp.net Web Api在配置路由的时候，</p>

<pre>GET("BanKa/GF/Activity.ashx/{user_id?}/{true_name?}/{mobile?}"</pre>


<p>那我们在相应的处理器中就可以</p>

<pre>public HttpResponseMessage Method(string user_id, string true_name, string mobile)</pre>


<p>此时这个方法中参数的值框架会给我们自动注入进来。</p>

<p>而在Spring中，框架严格区分@RequestParam跟@PathVariable两种类型，举个例子</p>

<pre>@ResponseBody
@RequestMapping(value = "NewPage/{id}/link.ashx", method = RequestMethod.GET)
public Object Qlink(@PathVariable String id,@RequestParam String citycode,@RequestParam(required = false) String callback)</pre>


<p>如果我们此时访问的地址是: NewPage/13/link.ashx?citycode=1234&amp;callback=abcd，那么上面方法的参数值就是13，1234，abcd</p>

<h5>Post</h5>

<p>这种情况下一般在Asp.net Web Api我们都会定义一个POCO，里面的属性就是NameValueCollection中的Name，框架会帮我们进行序列化，借助的ModelBinder这个类。</p>

<p>而Spring中我们一样，是一个POJO，我们会对它标注上@RequestBody，不过此时一般要求客户端过来的content-type是application/json，如果是application/x-www-form-urlencoded，此时方法参数就应该是MultiValueMap&lt;String, String>的一个实例，同样Spring的这个绑定借助的是FormHttpMessageConverter这个转换类。</p>

<h3>Others</h3>

<p>目前Asp.net WebApi所有的Controller都是继承自ApiController，而Spring早期一样，不过目前采用了注解的方式，任何一个类都可以充当Controller的角色，只要给他标识上@Controller或@RestController即可，当然，基于习惯，一般会将这种类以Controller结尾。不过最新版本的Asp.net WebApi据说也会去除强制继承模式了，这样看来，各个语言都是殊途同归啊。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Netty框架中的几个核心概念</title>
      <link href="http://sevenz.github.io/code/basis-knowledeg-in-netty/"/>
      <pubDate>2013-03-05T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/basis-knowledeg-in-netty</guid>
      <content:encoded><![CDATA[<p><a href="http://netty.io/" title="netty io">Netty</a> 在java世界中是一个非常知名的通迅框架，目前最新版本应该是5.x,不过3.x版本相对来讲在业界用的比较广泛，主要是从4.x版本开始重写了很多并对项目进行了重新分包。此框架可以让你在不是很熟悉NIO的基础上也可以写出高效的服务端代码。</p>

<p>下面说说在Netty中的几个重要概念。</p>

<h3>Bootstrap</h3>

<p>Bootstrap在Netty起到的是一个引导作用，相当于在这上面根据自己的业务场景做好配置。
<img src="/media/pic/netty-bootstrap.PNG" alt="Bootstrap inherit tree" /></p>

<h3>Channel</h3>

<p>Channel在Netty中是一个通迅载体，我们可以根据自己的业务场景选择它的一个具体类，下图反映的只是其中一小部分。
<img src="/media/pic/netty-channel.PNG" alt="Channel inherit tree" /></p>

<h3>ChannelHandler</h3>

<p>ChannelHandler在Netty中就是具体的业务逻辑处理实现类，通常我们会新建一个类继承自SimpleChannelInboundHandler，然后在里面通过重写相应的方法来。通过下图可以看出，其实在Netty中各种Decoder/Encoder其实也是一种Handler。
<img src="/media/pic/netty-channelhandler.PNG" alt="ChannelHandler inherit tree" /></p>

<h3>ChannelPipeline</h3>

<p>从上图中其实我们可以看出，ChannelPipeline的作用就是它会有一个列表，这个列表中存的东西就是我们自己配置进去的各种ChannelHandler的实例，可以说它是一个Netty程序的根本。因为，当有消息到达时，会在这列表中进行一个循环通知让各个handler去处理。</p>

<h3>ChannelInitializer</h3>

<p>ChannelInitializer在Netty中是用来配置ChannelHandler的，它通过上面的ChannelPipeline来添加ChannelHandler,ChannelInitializer本身也是一个ChannelHandler,它会在添加完其它handlers后自动从ChannelPipeline中删除自己。</p>

<h3>ByteBuf</h3>

<p>既然是通迅框架，肯定离不了数据的传送，在最新版本的Netty中，数据最终都会归为ByteBuf类。同时在框架中也提供了相应的实用类来进行相应的处理。
<img src="/media/pic/netty-buf.PNG" alt="Buffer" /></p>

<h3>EventLoopGroup/EventLoop</h3>

<p>顾名思义，EventLoopGroup可以包含多个EventLoop，每个Channel会绑定一个EventLoop，很多Channel可能会共享一个EventLoop。我们可以理解EventLoop是一个事件循环线程，而EventLoopGroup是一个事件循环集合。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>个人认为NET平台开发不可缺少的几个库</title>
      <link href="http://sevenz.github.io/code/the-library-common-used-in-net/"/>
      <pubDate>2013-01-16T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/the-library-common-used-in-net</guid>
      <content:encoded><![CDATA[<p>下面罗列一些个人认为NET平台开发不可缺少的几个库。</p>

<h2>ORM</h2>

<ol>
<li><a href="http://nhforge.org/" title="nhforge org">NHibernate</a></li>
<li><a href="https://github.com/StackExchange/dapper-dot-net" title="dapper">Dapper</a></li>
<li><a href="https://github.com/markrendle/Simple.Data" title="simple.data">Simple.Data</a></li>
</ol>


<h2>IOC/DI</h2>

<ol>
<li>Spring.NET</li>
<li><a href="https://github.com/structuremap/structuremap" title="structuremap">StructureMap</a></li>
<li><a href="http://autofac.org/" title="autofac">Autofac</a></li>
</ol>


<h2>Object Mapper</h2>

<ol>
<li><a href="https://emitmapper.codeplex.com/" title="emit">EmitMapper</a></li>
<li><a href="https://valueinjecter.codeplex.com/" title="valueinjecter">ValueInjecter</a></li>
<li><a href="https://github.com/AutoMapper/AutoMapper" title="automapper">AutoMapper</a></li>
</ol>


<h2>其它</h2>

<ol>
<li><a href="https://github.com/StackExchange/StackExchange.Redis" title="StackExchange.Redis">Redis Client</a></li>
<li><a href="http://james.newtonking.com/" title="Json.Net">Json.NET</a></li>
<li><a href="https://github.com/ServiceStack" title="Service.Text">Service.Text</a></li>
<li><a href="https://github.com/kevin-montrose/Jil" title="Jil">Jil</a></li>
</ol>

]]></content:encoded>
    </item>
    
    <item>
      <title>Asp.net Web Api中的Basic Authentication认证</title>
      <link href="http://sevenz.github.io/code/the-basic-authentication-in-asp.net-webapi/"/>
      <pubDate>2012-09-05T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/the-basic-authentication-in-asp.net-webapi</guid>
      <content:encoded><![CDATA[<p>在如今各种OPEN API数不胜数的年代，如何保证调用方是受信任的，考虑到大多数OPEN　API都是基于HTTP协议，此系列打算就以<strong>Basic Authentication</strong>开始介绍。</p>

<p>正如名字所示，basic authentication是http协议的一部分，是非常简单基本的，它的工作原理如下:</p>

<ol>
<li>客户端向服务端请求资源</li>
<li>服务端发现此资源需要认证并且客户端没提供资料说自己是谁，那么服务端返回401-Unauthorized status code,同时在响应头中添加WWW-Authenticate:Basic这个Key</li>
<li>此时客户端向服务端发送请求头Authorization:Basic ********</li>
<li>如果客户端的credentials经过服务器认证是正确的，那么向客户端返回200这个状态码，如果服务器认证不通过，则重复步骤2</li>
</ol>


<p>整个流程如下图所示：
<img src="/media/pic/basic-authentication.PNG" alt="Basic Authentication Flow" /></p>

<p>Asp.net Web Api中我们可以继承DelegatingHandler并重写相应方法，代码如下:</p>

<pre>public class AuthenticationHandler : DelegatingHandler 
{
    private const string SCHEME = "Basic";
    protected override System.Threading.Tasks.Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, System.Threading.CancellationToken cancellationToken)
    {
        var headers = request.Headers;
        if (headers.Authorization != null && SCHEME.Equals(headers.Authorization.Scheme))
        {
            Encoding encoding = Encoding.GetEncoding("iso-8859-1");
            string credentials = encoding.GetString(Convert.FromBase64String(headers.Authorization.Parameter));
            string[] parts = credentials.Split(':');
            string userId = parts[0].Trim();
            string password = parts[1].Trim();                 

            // TODO - Do authentication of userId and password against your credentials store here
            if (true)
            {                    
                IPrincipal principal = new CustomPrincipal(new CustomIdentity(userId));
                Thread.CurrentPrincipal = principal;
                if (HttpContext.Current != null)
                {
                    HttpContext.Current.User = principal;
                }
            }
        }
        var response = base.SendAsync(request, cancellationToken);
        return response.ContinueWith<HttpResponseMessage>(x =>
        {
            HttpResponseMessage message = x.Result;
            if (message.StatusCode == HttpStatusCode.Unauthorized)
            {
                message.Headers.WwwAuthenticate.Add(new AuthenticationHeaderValue(SCHEME));
            }
            return message;
        });
    }
}
</pre>


<p>CustomPrincipal跟CustomIdentity是IPrincipal及IIdentity的相应实现。
最后我们还需要把我们的这个Handler注册到系统中。</p>

<pre>config.MessageHandlers.Add(new AuthenticationHandler());
</pre>


<p>接下来就是发布了。</p>

<p>最后我们说说如何利用NET最新的HttpClient来访问，这里发下唠叨，话说NET平台下有WebClient,WebRequest，加上这个HttpClient,大家能知道他们的具体区别吗？</p>

<p>HttpClient有两种方式来访问这种类型的服务。</p>

<p>方法一：</p>

<pre>HttpClientHandler handler = new HttpClientHandler();
handler.Credentials = new NetworkCredential("username", "password");
using (HttpClient client = new HttpClient(handler)) {
    client.GetAsync("url").Result;
}
</pre>


<p>方法二：</p>

<pre>using (HttpClient client = new HttpClient(handler)) {
    string creds = String.Format("{0}:{1}", "badrddi", "badrddi");
    byte[] bytes = Encoding.ASCII.GetBytes(creds);
    var header = new AuthenticationHeaderValue("Basic", Convert.ToBase64String(bytes));
    client.DefaultRequestHeaders.Authorization = header;
    client.GetAsync("url").Result;
}
</pre>

]]></content:encoded>
    </item>
    
    <item>
      <title>谈谈C/S跟B/S系统开发中各自的关注点</title>
      <link href="http://sevenz.github.io/programmer-life/difference-between-cs-and-bs-system-develope/"/>
      <pubDate>2012-07-27T00:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/programmer-life/difference-between-cs-and-bs-system-develope</guid>
      <content:encoded><![CDATA[<p>何为B/S系统，个人理解就是用浏览器打开的应用都可以称之为B/S系统，常见的就是一些网站了。</p>

<p><strong>在B/S系统中，个人认为技术人员的积累主要在以下几个方面：</strong></p>

<ul>
<li>HTML + CSS + JavaScript。</li>
<li>各种脚本语言（PHP/ASP/JSP/Python/Ruby）操作服务器API。</li>
<li>服务器数据处理逻辑（O/R Mapping, 数据库连接池，各种如AOP等设计模式，甚至DSL等等）。</li>
<li>大型服务器的架构设计（分布式架构，各种负载均衡，服务器连接优化）。</li>
<li>数据库（分布式数据库，事务处理，大规模数据的存储、查询优化）。</li>
<li>大数据处理（Hadoop, Hive）等等。</li>
</ul>


<p>那么对于C/S系统来讲，又是如何的呢，不管是目前火热的手持设备开发，还是老早以前用PB,Delphi或现在的WPF开发的应用，都可以算是C/S系统，狭义的讲，如果是在Windows平台我们可以理解成就是一个.Exe。</p>

<p><strong>在C/S系统中，个人认为技术人员的积累主要在以下几个方面：</strong></p>

<ul>
<li>界面设计（各种UI控件，事件处理)。</li>
<li>数据处理逻辑（客户端缓存、多线程并发）。</li>
<li>网络数据处理。</li>
<li>平台相关特性（系统API调用，系统通知机制等）。</li>
<li>各种性能处理（比如不阻塞主线程等）。</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>苹果应用不同状态切换时的处理</title>
      <link href="http://sevenz.github.io/code/how-to-add-logic-when-lifestatus-changed-in-iphone/"/>
      <pubDate>2012-04-17T00:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/how-to-add-logic-when-lifestatus-changed-in-iphone</guid>
      <content:encoded><![CDATA[<p><strong>iphone 应用不同状态切换时回调的方法</strong></p>

<pre>
 application:didFinishLaunching:WithOptions:
 applicationDidBecomeActive:
 applicationWillEnterForeground:
 applicationWillResignActive:
 applicationDidEnterBackground:
 applicationWillTerminate:
 application:didChangeStatusBarFrame:
 UIApplicationDidReceiveMemoryWarningNotification:
</pre>


<p><strong>iphone 应用的几个状态</strong></p>

<ul>
<li>Not running:程序完全没有执行。</li>
<li>Inactive:程序在前景执行但是停止接收event,通常是因为系统有其它任务必须立刻告知使用者。</li>
<li>Active:程序在前景执行，且可以正常接收event。</li>
<li>Background:通常程序在要求进入suspend前会短暂进入此状态，程序可以做些收尾工作(ios4新增)。</li>
<li>Suspended:应用程序在背景但不会继续执行，此时依然留在主记忆中，因此重新唤起需要的资源较少。</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>NET平台WEB开发中微软框架外的选择--Nancy</title>
      <link href="http://sevenz.github.io/code/another-select-in-net-web-develope-using-nancy/"/>
      <pubDate>2012-03-10T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/another-select-in-net-web-develope-using-nancy</guid>
      <content:encoded><![CDATA[<p>NET平台做B/S开发，常见的比较正统的就是webform跟mvc两个框架，webform把B/S开发本质HTTP协议封装的死死的，将winform那套C/S模式搬到了B/S模式中，以至于好多做了几年B/S开发的伙计不知道http协议,不知道协议中状态码含义,不知道协议中各种响应的类型等等，mvc回归HTTP本质，扔掉了webform中广受诟病的各种控件，又让不少小伙伴很受伤，不知道怎么去开发，会了的又好像很了不起一样。其实不管如何，B/S开发，不管什么语言什么平台，说白了就是服务器端监听着某个端口，然后根据不同请求返回不同字符串，只是这字符串比较特殊，它要能让浏览器认识，仅此而已无它。</p>

<p>言归正传，介绍一款开源的框架，<a href="http://nancyfx.org/" title="nancy org">Nancy</a>，下面我们采用自集成的方式，简单来说就是让你不用布置在IIS上面，了解WCF的小伙伴对自集成的方式应该不会陌生。</p>

<p>我们需要添加如下两个程序集，</p>

<pre>Nancy.dll,Nancy.Hosting.Self.dll</pre>


<p>接下来继承NancyModule做如下自定义Moduld虚类，这个可以具体业务具体分析了，看是建还是不建。</p>

<pre>public abstract class BaseModule:NancyModule{
    public BaseModule():base(){
    
    }
    public BaseModule(string modulePath):base(modulePath){
        
    }
}
</pre>


<p>如果利用过asp.net mvc开发过项目的应该知道，在它的第二版中推出了area的概念，上面带参数的构造作用就在于此。</p>

<p>做个RootModule，当用户访问这个根地址的时候由来处理，代码如下</p>

<pre>public class RootModule:BaseModule{
    public RootModule():base(){
        Get["/"] = parameters => { return "Homepage"; };
    }
}</pre>


<p>这样假如你在本地监听的是http://localhost:8888/nancy/，那么你在浏览器里输入上述地址的时候浏览器中就会显示Homepage的字眼，parameters是一个key-value的字典，代表的是HTTP协议中前端GET，POST，DELETE，PUT过来的数据集。</p>

<p>在做另一个Moduel，</p>

<pre>public class PhotoModule:BaseModule{
    public PhotoModule(): base("/photo"){
        Get["/{slug}"] = parameters => {
            return String.Format("Photo {0}", parameters.slug);
        };
        Post["/{slug}/addcomment"] = parameters => {
            string photoSlug = Convert.ToString(parameters.slug);
            return Response.AsRedirect("/photo/" + photoSlug);
        };
    ｝
｝
</pre>


<p>可以看出，当我们访问http://localhost:8888/nancy/photo/1234的时候，将会在浏览器中打印出Photo 1234的字眼，当我们POST数据到http://localhost:8888/nancy/photo/aaa/addcomment的路径时，将重定向到http://localhost:8888/nancy/photo/aaa，从而显示Photo aaa字眼。</p>

<p>上面都是直接打印出一个字符串，我们可以通过设置Response的ContentType来达到返回json或者其它的功能。</p>

<pre>public class JsonModule:BaseModule{
    public JsonModule():base(){
        Get["/"] = parameters => {   
            Context.Response.ContentType = "application/json";
            JavaScriptSerializer js = new JavaScriptSerializer();
            StringBuilder sb = new StringBuilder();
            js.Serialize(new { id = 1, name = "bob" }, sb);
            return sb;
        };
    }
}
</pre>


<p>当然WEB开发中最主要的还是返回HTML，我们不可能在上面做字符串拼装，不现实，Nancy给我们考虑到了，相对来讲，还支持多种模板，Razor,Spark,DotLiquid,Markdown,Nustache都支持。</p>

<pre>public class HtmlModule:BaseModule{ 
   public JsonModule():base(){
       Get["/testing"] = parameters => {
           return View["staticview", modelname];
       };
   }
}
</pre>


<p>上面第一个参数是模板名称，第二个参数是传给模板的模型。</p>

<p>一般来讲，在做快速HTTP服务的时候，如果是NET平台，可以用其来做一个原型，实在是太方便了，特别是在当今移动终端及各种开放API的情况下，只提供数据，随便你们自己展示去。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>WEB开发中需要知道的缓存知识</title>
      <link href="http://sevenz.github.io/code/the-basic-cache-knowledge-in-http/"/>
      <pubDate>2010-06-05T20:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/the-basic-cache-knowledge-in-http</guid>
      <content:encoded><![CDATA[<p>WEB缓存游走于服务器和客户端间，服务器数量可能是1个或多个，客户端也可能是1个或多个，使用缓存的2个主要原因：</p>

<ul>
<li>降低延迟：缓存离客户端更近，因此从缓存请求内容比从源服务器所用时间少</li>
<li>降低网络传输：副本被重复使用，大大降低用户带宽使用，也是变相省钱，如果流量要付费的话
WEB缓存类型</li>
</ul>


<hr />

<ul>
<li>浏览器缓存：浏览器会在你硬盘上开辟一个空间专门存储资源，当您点击后退操作或点击一个之前看过的链接时就会很管用，这一部分缓存可以手动清空。
<img src="/media/pic/clear-cache.PNG" alt="clear cache" /></li>
<li>代理服务器缓存：并非客户端或服务端器的一部分，处于网络中，请求需要以某种方式路由到他们，一种是手动设置，告诉浏览器代理服务器地址(在翻墙中经常用到)；另一种就是使用拦截，这种方式下，客户端无需配置甚至都不知道已经被拦截了。</li>
<li>网关缓存：也被称为"反向代理缓存"或"替代缓存"。负载均衡<sup><a id="ref-1" href="#ref-note-1">[1]</a></sup>，内容分发<sup><a id="ref-2" href="#ref-note-2">[2]</a></sup>都属于这种。
WEB缓存如何工作</li>
</ul>


<hr />

<p>所有的缓存都有一套自己的规则，其中部分规则设定在协议中(HTTP)，部分则由缓存管理员<sup><a id="ref-3" href="#ref-note-3">[3]</a></sup>自己设置规则。</p>

<h5>一般而言有如下常用规则：</h5>

<ol>
<li>响应头明确说明，偶不想被缓存</li>
<li>如果请求信息是需要认证或安全加密的(HTTPS),相应内容不会被缓存</li>
<li>缓存如果有以下表现，则认为是新鲜的(无需检查服务器直接发送客户端)：含有完整过期时间和寿命控制头信息且内容仍在保鲜期以及缓存最近已更新且在不久前刚修改</li>
<li>特定情况下，如断网，之前有过的响应缓存而不检查服务器</li>
<li>若内容陈旧，则会要求服务器做验证或在响应头回应缓存其拷贝是否OK</li>
</ol>


<p>响应如果没有类似ETag或Last-Modified这样的头，也没有明确的更新信息，通常则认为是不可缓存的。</p>

<h2>如何控制缓存或不缓存 </h2>

<h5>HTTP头信息</h5>

<p>http头信息可让你对浏览器跟服务器间如何处理副本有更多的控制，它们在HTML代码中是看不见的，一般由WEB服务器自动生成，但是，根据你使用的服务器，可以在某种程度上进行控制，一般来讲，一个典型的HTTP协议返回的头信息如下所示：
<img src="/media/pic/response-head.PNG" alt="response head" /></p>

<h5>使用Expires HTTP头信息控制不过期</h5>

<p>Expires HTTP头是控制缓存的基本手段，Expires的中文意思是"有效期"，显然就是告诉浏览器缓存的有效期。如果过期，缓存会检查源服务器以确定文件是否改变了。Expires头几乎每个缓存都支持，对于静态图片而言，Expires头信息是相当有用的，因为图片不怎么变，可以给图片设置一个相当长过期时间，需要注意的是Expires的时间是格林威治时间(GMT)。尽管Expires头很有用，但它有一定的局限性。因为牵扯到时间，Web服务器端的时钟必须和缓存的同步。</p>

<h5>Cache-Control(缓存控制)HTTP头信息</h5>

<ul>
<li>max-age=[秒]:表示在这个时间范围内缓存是新鲜无需更新，相对时间</li>
<li>s-maxage=[秒]:类似前者，一般应用于共享缓存(代理)</li>
<li>public:标记认证的响应才能被缓存</li>
<li>private:允许缓存专门为某一用户存储响应</li>
<li>no-cache:每次在释放缓存副本之前都强制发送请求给服务器进行验证，这在确保认证有效性上很管用(和public结合使用)或者保证内容必须是即时的，不得无视缓存的所有优点，如国内的微博</li>
<li>no-store:强制缓存在任何情况下都不要保留任何副本</li>
<li>must-revalidate:告诉缓存，我给你准备了一些关于新鲜度的信息，在表现的时候要严格遵循之。HTTP允许缓存在某些特定情况下返回过期数据，指定了这个属性，相对于告诉缓存，你丫必须严格遵循我的规则</li>
<li>proxy-revalidate:同前者，只能用于代理缓存</li>
</ul>


<h5>验证器和验证</h5>

<p>服务器以及缓存通过验证来判断内容是否改变，在不确定内容是否过期的时候，可以避免本地已经存在副本的时候下载整个内容。验证器是很重要的，如果一个都没有，同时没有可用的新鲜度信息(Expires或Cache-Control)，缓存一点儿都不会存储内容。最常见的验证是通过Last-Modified头信息通信确定文档最后的修改时间，如果缓存有内容存储，会包含Last-Modified信息的，辅助If-Modified-Since请求，我们可以询问服务器内容是否改变了。</p>

<p>HTTP 1.1引入了一个新的验证器，称为Etag。Etag是每次展现内容改变时由服务器生成的唯一标识符，由于服务器控制ETag如何生成，当缓存发起If-None-Match请求的时候，如果Etag匹配，就可以确定展示内容其实是一样的。目前几乎所有的缓存使用Last-Modified时间作为验证器，Etag验证也开始变得流行。</p>

<p>所有新一代的Web服务器都对静态内容(如：文件)自动生成ETag和Last-Modified头信息，而你不必做任何设置。但是，服务器对于动态内容(例如：CGI, ASP或数据库生成的网站)并不知道如何生成这些信息，参考一下编写支持缓存的脚本章节</p>

<h2>常见技巧</h2>

<ul>
<li>保持URL稳定</li>
<li>不使用POST:若是获取数据，尽量不使用POST，这是因为POST方式返回内容大部分不会被缓存，相对地通过GET以获取信息被缓存存储下后后续使用</li>
<li>生成Content-Length头信息:这允许客户端在一个TCP/IP请求上请求多个内容，而不是为每次请求单独建立连接</li>
</ul>


<h2>注释</h2>


<ol class="notes">
<li id="ref-note-1"><a href="#ref-1">^</a>负载均衡：是一种采用各种分配算法把网络请求分散到一个服务器集群中的可用服务器上去，通过管理进入的Web数据流量和增加有效的网络带宽，从而使网络访问者获得尽可能最佳的联网体验的硬件设备。</li>
<li id="ref-note-2"><a href="#ref-2">^</a>内容分发：即CDN, 基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互 联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向 离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</li>
<li id="ref-note-3"><a href="#ref-3">^</a>缓存管理员：如果指的是浏览器缓存，则有可能就是我们服务器专家同事，在服务器上配置一些缓存规则；如果是代理缓存，则指的就是处理代理服务器这块的管理人员。</li>
</ol>



]]></content:encoded>
    </item>
    
  </channel>
</rss>
