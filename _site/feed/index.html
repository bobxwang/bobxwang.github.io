<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>bob</title>
    <link href="http://sevenz.github.io/feed/" rel="self" />
    <link href="http://webfrogs.github.com" />
    <lastBuildDate>2016-02-25T16:47:56+08:00</lastBuildDate>
    <webMaster>ccf.developer@gmail.com</webMaster>
    
    <item>
      <title>Spring Cloud--基础概念</title>
      <link href="http://sevenz.github.io/code/basic-knlowledge-in-spring-cloud/"/>
      <pubDate>2015-06-05T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/basic-knlowledge-in-spring-cloud</guid>
      <content:encoded><![CDATA[<p>当今微服务在博客，社交媒体或会议演讲中获得越来越多关注，同时社区中也有不少怀疑论者，认为其并不是很新东西，而是对SOA架构的重新包装。然而微服务架构模式却正在为敏捷部署及复杂企业应用提供巨大的帮助。如想获得微服务的最新消息，可以关注其<a href="http://microservices.io/">官网</a>。</p>

<p>跨入微服务领域意味着我们正式迎接分布式系统所带来的诸多挑战，而分布式系统绝不是那种能够"凑合使用"的方案。</p>

<p>jvm平台的著名开源库Spring将<a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/">spring-boot</a>与<a href="http://netflix.github.io/">netflix</a>的库相结合，推出了<a href="http://projects.spring.io/spring-cloud/spring-cloud.html">spring-cloud</a>。</p>

<p>spring-cloud为开发者提供了在分布式系统(如配置服务，服务发现，断路器，智能路由，控制总线，一次性Token，全局锁)等操作的开发工具，目前已经提供在<a href="http://mvnrepository.com/search?q=spring+cloud">Maven</a>中央仓库中。</p>

<p>spring cloud包含一大堆子项目，已经开源在github上面，可以在<a href="https://github.com/spring-cloud/">这里</a>查看。</p>

<blockquote><p><strong>spring cloud cli</strong></p>

<p><strong>spring cloud context</strong></p>

<p><strong>spring cloud commons</strong></p>

<p><strong>spring cloud config</strong></p>

<p><strong>spring cloud netflix</strong>：service discovery: Eureka; circuit breaker: Hystrix; client side loadbalancer: Ribbon; declarative rest client: Feign; router and filter: Zuul(Reverse Proxy)</p></blockquote>

<p>当然，服务注册发现这块，spring cloud除了netflix公司的Eureka之外，也可以选择consul或者zookeeper。</p>

<p>下文将会对每个子项目做个说明。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>scala中的隐式转换</title>
      <link href="http://sevenz.github.io/code/the-keyword-implicit-in-scala/"/>
      <pubDate>2014-04-01T22:23:09+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/the-keyword-implicit-in-scala</guid>
      <content:encoded><![CDATA[<h4>implicit</h4>

<p>在scala中有一个关键字，implicit，就是我们这篇文章的主题。
先看一个简单的例子：</p>

<pre>def display(input:String) = println(input)</pre>


<p>我们可以看到display函数的定义只接受String类型的参数，如果调用display("fucktest")不会有任何问题，但如果传参是非字符串的话，编译会通不过。
此时如果我们想让display可以接受其它类型的参数，除非我们重载它，重新定义一个其它类型有入参，此时implicit关键字就派上用场了，我们可以在相同的作用域内用implicit关键字定义一个隐式转换函数。</p>

<pre>object ImplicitTutorial{
    def display(input:String) = println(input)
    implicit def int2String(input:Int) = input.toString
    implicit def boolean2String(input:Boolean) = if(input) "true" else "false"
    def main(args:Array[String]):Unit = {
        def("fucktest") 
        def(2)
        def(true)
    }
}</pre>


<p>在这个作用域内，我们定义了两个隐式转换函数，这样dispay函数就能接受Int跟Boolean类型的参数了。
得出一个结论：</p>

<blockquote><p>隐式函数是指在同一个作用域下，一个给定参数类型并自动转换指定类型的函数，这个函数跟函数名字无关，跟入参参数名字无关，只和入参参数类型及返回类型相关，注意是同一个作用域。</p></blockquote>

<p>关于这点，在c#语言中一样存在implicit这个关键字</p>

<pre>class Machine {
    public int Value { get;set; }
    public static implicit operator ToWidget(Machine m) {
        Widget w = new Widegt();
        w.Value = m.Value * 2;
        return w;
    }
} 
class Widget {
    public int Value { get;set; }
    public static implicit operator ToMachine(Widget w) {
        Machine m = new Machine();
        m.Value = w.Value / 2;
        return m;
    }
}
class Program {
    static void Main() {
        Machine m = new Machine();
        m.Value = 5;
        // Implicit conversion from machine to widget.
        Widget w = m;
        Console.WriteLine(w.Value); // should print 10
        Machine m2 = w
        Console.WriteLine(w.Value); // should print 5
    }
}</pre>


<p>可以看到两个不同的语言用差不多的方法解决相似的类型转换问题。</p>

<h4>Type Extension</h4>

<p>不过，在c#中，有一个扩展方法(objective-c中也有相关概念，叫做<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html">Category</a>)，它让我们可以在不用继承的前提下对一个类进行扩展，在这概念出现前，我们一般会写一个工具类来处理，让我们看看是怎么实现的。</p>

<pre>public static class IntExtension{
    public static long plus(this int input,int another) {
        return input + another;
    }
}</pre>


<p>这样我们就为int这种类型添加了一个plus的方法，因此我们可以这样来调用</p>

<pre>int i = 5;
long result = i.plus(56)</pre>


<p>如果想在scala中实现相同的方案，我们可以变相的通过implicit来实现，下面是相应的代码实现。</p>

<pre>case class IntExtension(value:Int) {
    def plus(another:Int):Int = value + antoher
}
implicit def int2IntExtension(value:Int) = { IntExtension(value) }
val i = 45
val resutl = i.plus(3)
</pre>


<p>这样我们就实现了c#中的扩展方法。</p>

<blockquote><p>最后总结：</p>

<blockquote><p>隐式转换在同一个作用域中不能存在参数跟返回值完全相同的两个函数</p>

<p>隐式转换只在意输入类型，返回类型</p>

<p>隐式转换是scala语法灵活和简洁的重要组成部分</p></blockquote></blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Spark随谈--基础概念</title>
      <link href="http://sevenz.github.io/code/the-basic-concept-of-spark/"/>
      <pubDate>2014-01-05T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/the-basic-concept-of-spark</guid>
      <content:encoded><![CDATA[<blockquote><p><strong>Application</strong>:基于Spark的用户程序，包含了一个driver program和集群中多个executor</p>

<p><strong>Driver Program</strong>:运行Application的main()函数并创建SparkContext。通常SparkContext代表driver program</p>

<p><strong>Executor</strong>:为某Application运行在worker node上的一个进程。该进程负责运行Task，并负责将数据存在内存或者磁盘上。每个Application都有自己独立的executors</p>

<p><strong>Cluster Manager</strong>:在集群上获得资源的外部服务（例如 Spark Standalon，Mesos、Yarn)
<strong>Worker Node</strong>:集群中任何可运行Application代码的节点</p>

<p><strong>Task</strong>:被送到executor上执行的工作单元。</p>

<p><strong>Job</strong>:可以被拆分成Task并行计算的工作单元，一般由Spark Action触发的一次执行作业。</p>

<p><strong>Stage</strong>:每个Job会被拆分成很多组Task，每组任务被称为stage，也可称TaskSet。该术语可以经常在日志中看打。</p>

<p><strong>RDD</strong>:Spark的基本计算单元，通过Scala集合转化、读取数据集生成或者由其他RDD经过算子操作得到。</p></blockquote>

<h2>SparkConf</h2>

<p>对于spark的环境做一些基本设置</p>

<pre>conf = SparkConf().setAppName('APP_NAME')
conf.setMaster('local')
</pre>


<h2>SparkContext</h2>

<p>通过前面设置好的conf,构造出一个spark的上下文环境，作为一个操作和调度的总入口</p>

<pre>sc = SparkContext(conf=conf)
</pre>


<h2>RDD</h2>

<p><strong>Resilient Distributed Datasets</strong>，是一个容错的，并行的数据结构，可以让用户显示地将数据存储到磁盘和内存中，并能控制数据的分区，本质上，RDD是一个数据集。RDD将操作分成两类，<em>transformation</em>跟<em>action</em>，无论你执行了多少次transformation操作，RDD都不会真正执行运算，只有当action操作被执行时，运算才会触发，在其内部实现机制中是基于迭代器的，从而使数据的访问更高效。</p>

<p><strong>Transformation</strong>，根据现有的数据集创建一个新的数据集</p>

<ul>
<li><p>map(func):对调用map的RDD数据集中的每个element都使用func，然后返回一个新的RDD</p></li>
<li><p>filter(func):对调用filter的RDD数据集中的每个元素都使用func，然后返回一个包含使func为true的元素构成的RDD</p></li>
<li><p>flatMap(func):和map差不多，但是flatMap对于每个输入元素生成的是0或多个结果，因此func函数返回值不是一个单一元素，而是一个序列</p></li>
<li><p>groupByKey(numTasks):返回(K,Seq[V])，也就是hadoop中reduce函数接受的key-valuelist</p></li>
<li><p>reduceByKey(func,[numTasks]):就是用一个给定的reduce func再作用在groupByKey产生的(K,Seq[V]),比如求和，求平均数</p></li>
<li><p>sortByKey([ascending],[numTasks]):按照key来进行排序，是升序还是降序，ascending是boolean类型</p></li>
</ul>


<blockquote><p><strong>narrow dependencies</strong>
子RDD的每个分区依赖于常数个父分区（与数据规模无关）
输入输出一对一的算子，且结果RDD的分区结构不变。主要是map/flatmap
输入输出一对一的算子，但结果RDD的分区结构发生了变化，如union/coalesce
从输入中选择部分元素的算子，如filter、distinct、substract、sample</p>

<p><strong>wide dependencies</strong>
子RDD的每个分区依赖于所有的父RDD分区
对单个RDD基于key进行重组和reduce，如groupByKey，reduceByKey
对两个RDD基于key进行join和重组，如join
经过大量shuffle生成的RDD，建议进行缓存。这样避免失败后重新计算带来的开销。</p></blockquote>

<p><strong>Action</strong>，在数据集上运行计算后，返回一个值给驱动程序</p>

<ul>
<li><p>reduce(func):说白了就是聚集，接受传入的函数是两个参数输入返回一个值，这个函数必须是满足交换律和结合律的</p></li>
<li><p>saveAsTextFile(path):把dataset写到一个text file中，或者hdfs，或者hdfs支持的文件系统中，spark把每条记录都转换为一行记录，然后写到file中</p></li>
<li><p>saveAsSequenceFile(path):只能用在key-value对上，然后生成SequenceFile写到本地或者hadoop文件系统</p></li>
</ul>


<pre>data = [1,2,3,4,5]
distData = sc.parallelize(data)
lines = sc.textFile('data.txt')
linelengths = lines.map(lambda s: len(s))
totallength = linelengths.reduce(lambda a,b: a+b)
</pre>


<h2>Shared Variables</h2>

<p>一般来说，当一个函数被传给Spark操作(map/reduce)，通常是在集群结点上运行，在函数中使用到的所有变量都分别做拷贝供函数操作而不会相互影响，而在这些函数中对变量所做的所有更新都不会被传播回驱动程序。然而Spark提供两种有限的共享变量：广播跟累加。</p>

<h5>Broadcast Vaiables: 广播变量，可以在每台机器上缓存只读变量而不需要为各个任务发送该变量的拷贝，可以让大的输入数据集的集群拷贝中的节点更加高效</h5>

<pre>broadcastVar = sc.broadcase([1,2,3])
</pre>


<h5>Accumulators: 累加器，只有驱动程序才能获取累加器的值</h5>

<pre>accum = sc.accumulator(0)
sc.parallelize([1,2,3,4]).foreach(lambda x:accum.add(x))
</pre>

]]></content:encoded>
    </item>
    
    <item>
      <title>Asp.Net WebApi跟Spring Rest的Controller对比</title>
      <link href="http://sevenz.github.io/code/compare-the-aspwebapi-with-spring-rest/"/>
      <pubDate>2013-10-09T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/compare-the-aspwebapi-with-spring-rest</guid>
      <content:encoded><![CDATA[<p>自从11年底接触Asp.net Web Api开始到现在转眼也快三年了，做个日志对比下开源框架Spring Rest。</p>

<h3>Asp.net Web Api Controller Select &amp;&amp; Spring Rest Controller Select</h3>

<p>众所周知，HttpModule跟HttpHandler在Net Framework中是很重要的两个概念，在Web Api中一样，IIS接收到请求后，会查找一个叫做IRouteHandler的实现类，默认是HttpControllerRouterHander，中间会途径一系列的MessageHandler，HttpControllerDispatcher，DefaultHttpControllerActivator，最终会根据我们事先配置好的路由来选择一个Controller接收这个请求。</p>

<p>基于Spring的web应用最开始我们需要配一个DispatcherServlet的servlet-name，这个servlet会负责接收过来的所有请求，然后根据相应的配置<pre>HandlerMapping
--BeanNameUrlHandlerMapping
--SimpleUrlHandlerMapping
--ControllerClassNameHandlerMapping
--DefaultAnnotationHandlerMapping)</pre>选择一个具体的Controller来接收这个请求。</p>

<h3>Parameter Bind</h3>

<p>不管什么平台，客户端过来的数据服务端都会处理成一个NameValueCollection这样一个角色，然后我们自己根据相应的name在这个角色中获得value。不过如果需要我们自己去取，那这样也就谈不上框架了，太Low了点。</p>

<h5>Get</h5>

<p>Asp.net Web Api在配置路由的时候，</p>

<pre>GET("BanKa/GF/Activity.ashx/{user_id?}/{true_name?}/{mobile?}"</pre>


<p>那我们在相应的处理器中就可以</p>

<pre>public HttpResponseMessage Method(string user_id, string true_name, string mobile)</pre>


<p>此时这个方法中参数的值框架会给我们自动注入进来。</p>

<p>而在Spring中，框架严格区分@RequestParam跟@PathVariable两种类型，举个例子</p>

<pre>@ResponseBody
@RequestMapping(value = "NewPage/{id}/link.ashx", method = RequestMethod.GET)
public Object Qlink(@PathVariable String id,@RequestParam String citycode,@RequestParam(required = false) String callback)</pre>


<p>如果我们此时访问的地址是: NewPage/13/link.ashx?citycode=1234&amp;callback=abcd，那么上面方法的参数值就是13，1234，abcd</p>

<h5>Post</h5>

<p>这种情况下一般在Asp.net Web Api我们都会定义一个POCO，里面的属性就是NameValueCollection中的Name，框架会帮我们进行序列化，借助的ModelBinder这个类。</p>

<p>而Spring中我们一样，是一个POJO，我们会对它标注上@RequestBody，不过此时一般要求客户端过来的content-type是application/json，如果是application/x-www-form-urlencoded，此时方法参数就应该是MultiValueMap&lt;String, String>的一个实例，同样Spring的这个绑定借助的是FormHttpMessageConverter这个转换类。</p>

<h3>Others</h3>

<p>目前Asp.net WebApi所有的Controller都是继承自ApiController，而Spring早期一样，不过目前采用了注解的方式，任何一个类都可以充当Controller的角色，只要给他标识上@Controller或@RestController即可，当然，基于习惯，一般会将这种类以Controller结尾。不过最新版本的Asp.net WebApi据说也会去除强制继承模式了，这样看来，各个语言都是殊途同归啊。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Netty框架中的几个核心概念</title>
      <link href="http://sevenz.github.io/code/basis-knowledeg-in-netty/"/>
      <pubDate>2013-03-05T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/basis-knowledeg-in-netty</guid>
      <content:encoded><![CDATA[<p><a href="http://netty.io/" title="netty io">Netty</a> 在java世界中是一个非常知名的通迅框架，目前最新版本应该是5.x,不过3.x版本相对来讲在业界用的比较广泛，主要是从4.x版本开始重写了很多并对项目进行了重新分包。此框架可以让你在不是很熟悉NIO的基础上也可以写出高效的服务端代码。</p>

<p>下面说说在Netty中的几个重要概念。</p>

<h3>Bootstrap</h3>

<p>Bootstrap在Netty起到的是一个引导作用，相当于在这上面根据自己的业务场景做好配置。
<img src="/media/pic/netty-bootstrap.PNG" alt="Bootstrap inherit tree" /></p>

<h3>Channel</h3>

<p>Channel在Netty中是一个通迅载体，我们可以根据自己的业务场景选择它的一个具体类，下图反映的只是其中一小部分。
<img src="/media/pic/netty-channel.PNG" alt="Channel inherit tree" /></p>

<h3>ChannelHandler</h3>

<p>ChannelHandler在Netty中就是具体的业务逻辑处理实现类，通常我们会新建一个类继承自SimpleChannelInboundHandler，然后在里面通过重写相应的方法来。通过下图可以看出，其实在Netty中各种Decoder/Encoder其实也是一种Handler。
<img src="/media/pic/netty-channelhandler.PNG" alt="ChannelHandler inherit tree" /></p>

<h3>ChannelPipeline</h3>

<p>从上图中其实我们可以看出，ChannelPipeline的作用就是它会有一个列表，这个列表中存的东西就是我们自己配置进去的各种ChannelHandler的实例，可以说它是一个Netty程序的根本。因为，当有消息到达时，会在这列表中进行一个循环通知让各个handler去处理。</p>

<h3>ChannelInitializer</h3>

<p>ChannelInitializer在Netty中是用来配置ChannelHandler的，它通过上面的ChannelPipeline来添加ChannelHandler,ChannelInitializer本身也是一个ChannelHandler,它会在添加完其它handlers后自动从ChannelPipeline中删除自己。</p>

<h3>ByteBuf</h3>

<p>既然是通迅框架，肯定离不了数据的传送，在最新版本的Netty中，数据最终都会归为ByteBuf类。同时在框架中也提供了相应的实用类来进行相应的处理。
<img src="/media/pic/netty-buf.PNG" alt="Buffer" /></p>

<h3>EventLoopGroup/EventLoop</h3>

<p>顾名思义，EventLoopGroup可以包含多个EventLoop，每个Channel会绑定一个EventLoop，很多Channel可能会共享一个EventLoop。我们可以理解EventLoop是一个事件循环线程，而EventLoopGroup是一个事件循环集合。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>个人认为NET平台开发不可缺少的几个库</title>
      <link href="http://sevenz.github.io/code/the-library-common-used-in-net/"/>
      <pubDate>2013-01-16T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/the-library-common-used-in-net</guid>
      <content:encoded><![CDATA[<p>下面罗列一些个人认为NET平台开发不可缺少的几个库。</p>

<h2>ORM</h2>

<ol>
<li><a href="http://nhforge.org/" title="nhforge org">NHibernate</a></li>
<li><a href="https://github.com/StackExchange/dapper-dot-net" title="dapper">Dapper</a></li>
<li><a href="https://github.com/markrendle/Simple.Data" title="simple.data">Simple.Data</a></li>
</ol>


<h2>IOC/DI</h2>

<ol>
<li>Spring.NET</li>
<li><a href="https://github.com/structuremap/structuremap" title="structuremap">StructureMap</a></li>
<li><a href="http://autofac.org/" title="autofac">Autofac</a></li>
</ol>


<h2>Object Mapper</h2>

<ol>
<li><a href="https://emitmapper.codeplex.com/" title="emit">EmitMapper</a></li>
<li><a href="https://valueinjecter.codeplex.com/" title="valueinjecter">ValueInjecter</a></li>
<li><a href="https://github.com/AutoMapper/AutoMapper" title="automapper">AutoMapper</a></li>
</ol>


<h2>其它</h2>

<ol>
<li><a href="https://github.com/StackExchange/StackExchange.Redis" title="StackExchange.Redis">Redis Client</a></li>
<li><a href="http://james.newtonking.com/" title="Json.Net">Json.NET</a></li>
<li><a href="https://github.com/ServiceStack" title="Service.Text">Service.Text</a></li>
<li><a href="https://github.com/kevin-montrose/Jil" title="Jil">Jil</a></li>
</ol>

]]></content:encoded>
    </item>
    
    <item>
      <title>Asp.net Web Api中的Basic Authentication认证</title>
      <link href="http://sevenz.github.io/code/the-basic-authentication-in-asp.net-webapi/"/>
      <pubDate>2012-09-05T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/the-basic-authentication-in-asp.net-webapi</guid>
      <content:encoded><![CDATA[<p>在如今各种OPEN API数不胜数的年代，如何保证调用方是受信任的，考虑到大多数OPEN　API都是基于HTTP协议，此系列打算就以<strong>Basic Authentication</strong>开始介绍。</p>

<p>正如名字所示，basic authentication是http协议的一部分，是非常简单基本的，它的工作原理如下:</p>

<ol>
<li>客户端向服务端请求资源</li>
<li>服务端发现此资源需要认证并且客户端没提供资料说自己是谁，那么服务端返回401-Unauthorized status code,同时在响应头中添加WWW-Authenticate:Basic这个Key</li>
<li>此时客户端向服务端发送请求头Authorization:Basic ********</li>
<li>如果客户端的credentials经过服务器认证是正确的，那么向客户端返回200这个状态码，如果服务器认证不通过，则重复步骤2</li>
</ol>


<p>整个流程如下图所示：
<img src="/media/pic/basic-authentication.PNG" alt="Basic Authentication Flow" /></p>

<p>Asp.net Web Api中我们可以继承DelegatingHandler并重写相应方法，代码如下:</p>

<pre>public class AuthenticationHandler : DelegatingHandler 
{
    private const string SCHEME = "Basic";
    protected override System.Threading.Tasks.Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, System.Threading.CancellationToken cancellationToken)
    {
        var headers = request.Headers;
        if (headers.Authorization != null && SCHEME.Equals(headers.Authorization.Scheme))
        {
            Encoding encoding = Encoding.GetEncoding("iso-8859-1");
            string credentials = encoding.GetString(Convert.FromBase64String(headers.Authorization.Parameter));
            string[] parts = credentials.Split(':');
            string userId = parts[0].Trim();
            string password = parts[1].Trim();                 

            // TODO - Do authentication of userId and password against your credentials store here
            if (true)
            {                    
                IPrincipal principal = new CustomPrincipal(new CustomIdentity(userId));
                Thread.CurrentPrincipal = principal;
                if (HttpContext.Current != null)
                {
                    HttpContext.Current.User = principal;
                }
            }
        }
        var response = base.SendAsync(request, cancellationToken);
        return response.ContinueWith<HttpResponseMessage>(x =>
        {
            HttpResponseMessage message = x.Result;
            if (message.StatusCode == HttpStatusCode.Unauthorized)
            {
                message.Headers.WwwAuthenticate.Add(new AuthenticationHeaderValue(SCHEME));
            }
            return message;
        });
    }
}
</pre>


<p>CustomPrincipal跟CustomIdentity是IPrincipal及IIdentity的相应实现。
最后我们还需要把我们的这个Handler注册到系统中。</p>

<pre>config.MessageHandlers.Add(new AuthenticationHandler());
</pre>


<p>接下来就是发布了。</p>

<p>最后我们说说如何利用NET最新的HttpClient来访问，这里发下唠叨，话说NET平台下有WebClient,WebRequest，加上这个HttpClient,大家能知道他们的具体区别吗？</p>

<p>HttpClient有两种方式来访问这种类型的服务。</p>

<p>方法一：</p>

<pre>HttpClientHandler handler = new HttpClientHandler();
handler.Credentials = new NetworkCredential("username", "password");
using (HttpClient client = new HttpClient(handler)) {
    client.GetAsync("url").Result;
}
</pre>


<p>方法二：</p>

<pre>using (HttpClient client = new HttpClient(handler)) {
    string creds = String.Format("{0}:{1}", "badrddi", "badrddi");
    byte[] bytes = Encoding.ASCII.GetBytes(creds);
    var header = new AuthenticationHeaderValue("Basic", Convert.ToBase64String(bytes));
    client.DefaultRequestHeaders.Authorization = header;
    client.GetAsync("url").Result;
}
</pre>

]]></content:encoded>
    </item>
    
    <item>
      <title>谈谈C/S跟B/S系统开发中各自的关注点</title>
      <link href="http://sevenz.github.io/programmer-life/difference-between-cs-and-bs-system-develope/"/>
      <pubDate>2012-07-27T00:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/programmer-life/difference-between-cs-and-bs-system-develope</guid>
      <content:encoded><![CDATA[<p>何为B/S系统，个人理解就是用浏览器打开的应用都可以称之为B/S系统，常见的就是一些网站了。</p>

<p><strong>在B/S系统中，个人认为技术人员的积累主要在以下几个方面：</strong></p>

<ul>
<li>HTML + CSS + JavaScript。</li>
<li>各种脚本语言（PHP/ASP/JSP/Python/Ruby）操作服务器API。</li>
<li>服务器数据处理逻辑（O/R Mapping, 数据库连接池，各种如AOP等设计模式，甚至DSL等等）。</li>
<li>大型服务器的架构设计（分布式架构，各种负载均衡，服务器连接优化）。</li>
<li>数据库（分布式数据库，事务处理，大规模数据的存储、查询优化）。</li>
<li>大数据处理（Hadoop, Hive）等等。</li>
</ul>


<p>那么对于C/S系统来讲，又是如何的呢，不管是目前火热的手持设备开发，还是老早以前用PB,Delphi或现在的WPF开发的应用，都可以算是C/S系统，狭义的讲，如果是在Windows平台我们可以理解成就是一个.Exe。</p>

<p><strong>在C/S系统中，个人认为技术人员的积累主要在以下几个方面：</strong></p>

<ul>
<li>界面设计（各种UI控件，事件处理)。</li>
<li>数据处理逻辑（客户端缓存、多线程并发）。</li>
<li>网络数据处理。</li>
<li>平台相关特性（系统API调用，系统通知机制等）。</li>
<li>各种性能处理（比如不阻塞主线程等）。</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>苹果应用不同状态切换时的处理</title>
      <link href="http://sevenz.github.io/code/how-to-add-logic-when-lifestatus-changed-in-iphone/"/>
      <pubDate>2012-04-17T00:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/how-to-add-logic-when-lifestatus-changed-in-iphone</guid>
      <content:encoded><![CDATA[<p><strong>iphone 应用不同状态切换时回调的方法</strong></p>

<pre>
 application:didFinishLaunching:WithOptions:
 applicationDidBecomeActive:
 applicationWillEnterForeground:
 applicationWillResignActive:
 applicationDidEnterBackground:
 applicationWillTerminate:
 application:didChangeStatusBarFrame:
 UIApplicationDidReceiveMemoryWarningNotification:
</pre>


<p><strong>iphone 应用的几个状态</strong></p>

<ul>
<li>Not running:程序完全没有执行。</li>
<li>Inactive:程序在前景执行但是停止接收event,通常是因为系统有其它任务必须立刻告知使用者。</li>
<li>Active:程序在前景执行，且可以正常接收event。</li>
<li>Background:通常程序在要求进入suspend前会短暂进入此状态，程序可以做些收尾工作(ios4新增)。</li>
<li>Suspended:应用程序在背景但不会继续执行，此时依然留在主记忆中，因此重新唤起需要的资源较少。</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>NET平台WEB开发中微软框架外的选择--Nancy</title>
      <link href="http://sevenz.github.io/code/another-select-in-net-web-develope-using-nancy/"/>
      <pubDate>2012-03-10T22:17:59+08:00</pubDate>
      <author>bob</author>
      <guid>http://sevenz.github.io/code/another-select-in-net-web-develope-using-nancy</guid>
      <content:encoded><![CDATA[<p>NET平台做B/S开发，常见的比较正统的就是webform跟mvc两个框架，webform把B/S开发本质HTTP协议封装的死死的，将winform那套C/S模式搬到了B/S模式中，以至于好多做了几年B/S开发的伙计不知道http协议,不知道协议中状态码含义,不知道协议中各种响应的类型等等，mvc回归HTTP本质，扔掉了webform中广受诟病的各种控件，又让不少小伙伴很受伤，不知道怎么去开发，会了的又好像很了不起一样。其实不管如何，B/S开发，不管什么语言什么平台，说白了就是服务器端监听着某个端口，然后根据不同请求返回不同字符串，只是这字符串比较特殊，它要能让浏览器认识，仅此而已无它。</p>

<p>言归正传，介绍一款开源的框架，<a href="http://nancyfx.org/" title="nancy org">Nancy</a>，下面我们采用自集成的方式，简单来说就是让你不用布置在IIS上面，了解WCF的小伙伴对自集成的方式应该不会陌生。</p>

<p>我们需要添加如下两个程序集，</p>

<pre>Nancy.dll,Nancy.Hosting.Self.dll</pre>


<p>接下来继承NancyModule做如下自定义Moduld虚类，这个可以具体业务具体分析了，看是建还是不建。</p>

<pre>public abstract class BaseModule:NancyModule{
    public BaseModule():base(){
    
    }
    public BaseModule(string modulePath):base(modulePath){
        
    }
}
</pre>


<p>如果利用过asp.net mvc开发过项目的应该知道，在它的第二版中推出了area的概念，上面带参数的构造作用就在于此。</p>

<p>做个RootModule，当用户访问这个根地址的时候由来处理，代码如下</p>

<pre>public class RootModule:BaseModule{
    public RootModule():base(){
        Get["/"] = parameters => { return "Homepage"; };
    }
}</pre>


<p>这样假如你在本地监听的是http://localhost:8888/nancy/，那么你在浏览器里输入上述地址的时候浏览器中就会显示Homepage的字眼，parameters是一个key-value的字典，代表的是HTTP协议中前端GET，POST，DELETE，PUT过来的数据集。</p>

<p>在做另一个Moduel，</p>

<pre>public class PhotoModule:BaseModule{
    public PhotoModule(): base("/photo"){
        Get["/{slug}"] = parameters => {
            return String.Format("Photo {0}", parameters.slug);
        };
        Post["/{slug}/addcomment"] = parameters => {
            string photoSlug = Convert.ToString(parameters.slug);
            return Response.AsRedirect("/photo/" + photoSlug);
        };
    ｝
｝
</pre>


<p>可以看出，当我们访问http://localhost:8888/nancy/photo/1234的时候，将会在浏览器中打印出Photo 1234的字眼，当我们POST数据到http://localhost:8888/nancy/photo/aaa/addcomment的路径时，将重定向到http://localhost:8888/nancy/photo/aaa，从而显示Photo aaa字眼。</p>

<p>上面都是直接打印出一个字符串，我们可以通过设置Response的ContentType来达到返回json或者其它的功能。</p>

<pre>public class JsonModule:BaseModule{
    public JsonModule():base(){
        Get["/"] = parameters => {   
            Context.Response.ContentType = "application/json";
            JavaScriptSerializer js = new JavaScriptSerializer();
            StringBuilder sb = new StringBuilder();
            js.Serialize(new { id = 1, name = "bob" }, sb);
            return sb;
        };
    }
}
</pre>


<p>当然WEB开发中最主要的还是返回HTML，我们不可能在上面做字符串拼装，不现实，Nancy给我们考虑到了，相对来讲，还支持多种模板，Razor,Spark,DotLiquid,Markdown,Nustache都支持。</p>

<pre>public class HtmlModule:BaseModule{ 
   public JsonModule():base(){
       Get["/testing"] = parameters => {
           return View["staticview", modelname];
       };
   }
}
</pre>


<p>上面第一个参数是模板名称，第二个参数是传给模板的模型。</p>

<p>一般来讲，在做快速HTTP服务的时候，如果是NET平台，可以用其来做一个原型，实在是太方便了，特别是在当今移动终端及各种开放API的情况下，只提供数据，随便你们自己展示去。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
