---
layout: post
title:  "WEB开发中需要知道的缓存知识"
date:   2010-06-05 12:17:59
categories: 
- code 
tags:
- web

---
WEB缓存游走于服务器和客户端间，服务器数量可能是1个或多个，客户端也可能是1个或多个，使用缓存的2个主要原因：

+ 降低延迟：缓存离客户端更近，因此从缓存请求内容比从源服务器所用时间少
+ 降低网络传输：副本被重复使用，大大降低用户带宽使用，也是变相省钱，如果流量要付费的话
WEB缓存类型
---
+ 浏览器缓存：浏览器会在你硬盘上开辟一个空间专门存储资源，当您点击后退操作或点击一个之前看过的链接时就会很管用，这一部分缓存可以手动清空。
![clear cache](/media/pic/clear-cache.PNG)
+ 代理服务器缓存：并非客户端或服务端器的一部分，处于网络中，请求需要以某种方式路由到他们，一种是手动设置，告诉浏览器代理服务器地址(在翻墙中经常用到)；另一种就是使用拦截，这种方式下，客户端无需配置甚至都不知道已经被拦截了。
+ 网关缓存：也被称为"反向代理缓存"或"替代缓存"。负载均衡<sup><a id="ref-1" href="#ref-note-1">[1]</a></sup>，内容分发<sup><a id="ref-2" href="#ref-note-2">[2]</a></sup>都属于这种。
WEB缓存如何工作
---
所有的缓存都有一套自己的规则，其中部分规则设定在协议中(HTTP)，部分则由缓存管理员<sup><a id="ref-3" href="#ref-note-3">[3]</a></sup>自己设置规则。
#####一般而言有如下常用规则：
1. 响应头明确说明，偶不想被缓存
2. 如果请求信息是需要认证或安全加密的(HTTPS),相应内容不会被缓存
3. 缓存如果有以下表现，则认为是新鲜的(无需检查服务器直接发送客户端)：含有完整过期时间和寿命控制头信息且内容仍在保鲜期以及缓存最近已更新且在不久前刚修改
4. 特定情况下，如断网，之前有过的响应缓存而不检查服务器
5. 若内容陈旧，则会要求服务器做验证或在响应头回应缓存其拷贝是否OK

响应如果没有类似ETag或Last-Modified这样的头，也没有明确的更新信息，通常则认为是不可缓存的。
如何控制缓存或不缓存 
---

#####HTTP头信息
http头信息可让你对浏览器跟服务器间如何处理副本有更多的控制，它们在HTML代码中是看不见的，一般由WEB服务器自动生成，但是，根据你使用的服务器，可以在某种程度上进行控制，一般来讲，一个典型的HTTP协议返回的头信息如下所示：
![response head](/media/pic/response-head.PNG)

#####使用Expires HTTP头信息控制不过期
Expires HTTP头是控制缓存的基本手段，Expires的中文意思是"有效期"，显然就是告诉浏览器缓存的有效期。如果过期，缓存会检查源服务器以确定文件是否改变了。Expires头几乎每个缓存都支持，对于静态图片而言，Expires头信息是相当有用的，因为图片不怎么变，可以给图片设置一个相当长过期时间，需要注意的是Expires的时间是格林威治时间(GMT)。尽管Expires头很有用，但它有一定的局限性。因为牵扯到时间，Web服务器端的时钟必须和缓存的同步。

#####Cache-Control(缓存控制)HTTP头信息
+ max-age=[秒]:表示在这个时间范围内缓存是新鲜无需更新，相对时间 
+ s-maxage=[秒]:类似前者，一般应用于共享缓存(代理)
+ public:标记认证的响应才能被缓存
+ private:允许缓存专门为某一用户存储响应
+ no-cache:每次在释放缓存副本之前都强制发送请求给服务器进行验证，这在确保认证有效性上很管用(和public结合使用)或者保证内容必须是即时的，不得无视缓存的所有优点，如国内的微博
+ no-store:强制缓存在任何情况下都不要保留任何副本
+ must-revalidate:告诉缓存，我给你准备了一些关于新鲜度的信息，在表现的时候要严格遵循之。HTTP允许缓存在某些特定情况下返回过期数据，指定了这个属性，相对于告诉缓存，你丫必须严格遵循我的规则
+ proxy-revalidate:同前者，只能用于代理缓存

#####验证器和验证
服务器以及缓存通过验证来判断内容是否改变，在不确定内容是否过期的时候，可以避免本地已经存在副本的时候下载整个内容。验证器是很重要的，如果一个都没有，同时没有可用的新鲜度信息(Expires或Cache-Control)，缓存一点儿都不会存储内容。最常见的验证是通过Last-Modified头信息通信确定文档最后的修改时间，如果缓存有内容存储，会包含Last-Modified信息的，辅助If-Modified-Since请求，我们可以询问服务器内容是否改变了。

HTTP 1.1引入了一个新的验证器，称为Etag。Etag是每次展现内容改变时由服务器生成的唯一标识符，由于服务器控制ETag如何生成，当缓存发起If-None-Match请求的时候，如果Etag匹配，就可以确定展示内容其实是一样的。目前几乎所有的缓存使用Last-Modified时间作为验证器，Etag验证也开始变得流行。

所有新一代的Web服务器都对静态内容(如：文件)自动生成ETag和Last-Modified头信息，而你不必做任何设置。但是，服务器对于动态内容(例如：CGI, ASP或数据库生成的网站)并不知道如何生成这些信息，参考一下编写支持缓存的脚本章节

常见技巧
---
+ 保持URL稳定
+ 不使用POST:若是获取数据，尽量不使用POST，这是因为POST方式返回内容大部分不会被缓存，相对地通过GET以获取信息被缓存存储下后后续使用
+ 生成Content-Length头信息:这允许客户端在一个TCP/IP请求上请求多个内容，而不是为每次请求单独建立连接


<h2>注释</h2>
<ol class="notes">
<li id="ref-note-1"><a href="#ref-1">^</a>负载均衡：是一种采用各种分配算法把网络请求分散到一个服务器集群中的可用服务器上去，通过管理进入的Web数据流量和增加有效的网络带宽，从而使网络访问者获得尽可能最佳的联网体验的硬件设备。</li>
<li id="ref-note-2"><a href="#ref-2">^</a>内容分发：即CDN, 基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互 联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向 离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</li>
<li id="ref-note-3"><a href="#ref-3">^</a>缓存管理员：如果指的是浏览器缓存，则有可能就是我们服务器专家同事，在服务器上配置一些缓存规则；如果是代理缓存，则指的就是处理代理服务器这块的管理人员。</li>
</ol>




